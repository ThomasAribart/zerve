import { ModuleSpec } from "@zerve/core";
import { readdir, writeFile, readFile } from "fs-extra";
import { join } from "path";

const toolsPackageRoot = process.cwd();
const repoRoot = join(toolsPackageRoot, "../..");
const modulesRoot = join(repoRoot, "packages/modules");
const modulesPackagePath = join(modulesRoot, "package.json");
const modulesIndexTsPath = join(modulesRoot, "index.ts");
const modulesConfigPath = join(modulesRoot, "modules.config.js");

const modulesConfig = require(modulesConfigPath);

function generateIndexTs(moduleSpecs: Record<string, ModuleSpec>) {
  return `// !!! ðŸ›‘  DO NOT EDIT THIS FILE BY HAND
// THIS FILE IS GENERATED BY packages/modules-tools/prepareModules.ts

${Object.keys(moduleSpecs)
  .map((moduleName) => `import ${moduleName}Module from "./${moduleName}";`)
  .join("\n")}

export const AllModules = {
${Object.keys(moduleSpecs)
  .map((moduleName) => `  ${moduleName}: ${moduleName}Module,`)
  .join("\n")}
};
    
${Object.keys(moduleSpecs)
  .map((moduleName) => `export const ${moduleName} = ${moduleName}Module;`)
  .join("\n")}
    
// Module Specs:
// ${JSON.stringify(moduleSpecs)}

// END AUTO-GENERATED BY packages/modules-tools/prepareModules.ts
`;
}

async function applyFile(filePath: string, fileData: any): Promise<boolean> {
  let prevDataValue = null;
  try {
    prevDataValue = await readFile(filePath, {
      encoding: "utf8",
    });
  } catch (e) {}

  if (fileData !== prevDataValue) {
    await writeFile(filePath, fileData);
    return true;
  }
  return false;
}

export async function prepareModules(includedModules: string[]) {
  const listedModules = await readdir(modulesRoot);

  const { localIncludedModules } = modulesConfig;

  const dependencies: Record<string, string> = {
    "@zerve/core": "*",
  };

  const moduleSpecs = Object.fromEntries(
    await Promise.all(
      localIncludedModules.map(async (moduleName) => {
        try {
          const moduleSpecData = await readFile(
            join(modulesRoot, moduleName, "module.json"),
            { encoding: "utf8" }
          );
          const moduleSpec = JSON.parse(moduleSpecData);
          // todo validate module spec
          return [moduleName, moduleSpec as ModuleSpec];
        } catch (e) {
          console.error(`Failed to read module file of ${moduleName}`);
          return [moduleName, {}];
        }
      })
    )
  );

  Object.entries(moduleSpecs).forEach(
    ([moduleName, moduleSpec]: [string, ModuleSpec]) => {
      if (moduleSpec.npmDependencies) {
        Object.entries(moduleSpec.npmDependencies).map(
          ([npmDepName, npmDepValue]) => {
            const prevDep = dependencies[npmDepName];
            if (prevDep === undefined) {
              dependencies[npmDepName] = npmDepValue;
            } else if (prevDep !== npmDepValue) {
              throw new Error(
                `Unable to handle unmatching npm dependencies of modules. Module "${moduleName}" requires "${npmDepName}"@${npmDepValue} but other modules require ${npmDepName} with version "${prevDep}".`
              );
            } else {
              // dep already set correctly
            }
          }
        );
      }
    }
  );

  const packageJson = {
    "//": "ðŸ›‘  DO NOT EDIT MANUALLY. FILE GENERATED BY packages/modules-tools/prepareModules.ts",
    name: "@zerve/modules",
    version: "0.0.0",
    private: true,
    dependencies,
    main: "./index.ts",
    types: "./index.ts",
    devDependencies: {
      config: "*",
      tsconfig: "*",
      typescript: "^4.5.5",
    },
  };

  const modulesPkgData = JSON.stringify(packageJson, null, 2);
  const hasAppliedModule = await applyFile(modulesPackagePath, modulesPkgData);
  const hasAppliedIndexTs = await applyFile(
    modulesIndexTsPath,
    generateIndexTs(moduleSpecs)
  );
  await Promise.all(
    Object.entries(moduleSpecs).map(async ([moduleName, moduleSpec]) => {
      const moduleIndexTsPath = join(modulesRoot, moduleName, "index.ts");

      await applyFile(
        moduleIndexTsPath,
        `// !!! ðŸ›‘  DO NOT EDIT THIS FILE BY HAND
// THIS FILE IS GENERATED BY packages/modules-tools/prepareModules.ts

import { defineModule } from "@zerve/core";

${
  moduleSpec.state
    ? `import ${moduleName}State from "${moduleSpec.state}";`
    : ""
}
${
  moduleSpec.actions
    ? `import ${moduleName}Actions from "${moduleSpec.actions}";`
    : ""
}

const ${moduleName} = defineModule(
  "${moduleName}",
  ${JSON.stringify(moduleSpec)},
  ${
    moduleSpec.state
      ? `${moduleName}State`
      : '{ schema: { type: "null" } as const }'
  },
  ${moduleSpec.actions ? `${moduleName}Actions` : "{}"},
);

export default ${moduleName};

// END AUTO-GENERATED BY packages/modules-tools/prepareModules.ts
`
      );
    })
  );
  if (hasAppliedModule)
    console.log(
      "ðŸŸ¢ Modules package.json written successfully. ðŸ›‘ Re-run yarn to install module dependencies! ðŸ›‘"
    );
  if (hasAppliedIndexTs)
    console.log("ðŸŸ¢ Modules index.ts written successfully.");

  if (hasAppliedModule) {
    throw new Error("ðŸ›‘ Re-run yarn to install module dependencies");
  }

  console.log("âœ… Modules are configured correctly.");
}

prepareModules([])
  .then(() => {
    // console.log("done.");
  })
  .catch((e) => {
    console.error(e);
  });
